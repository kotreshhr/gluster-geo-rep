import sys
import os
import json

GFID_ACCESS = 'python $1'
SYNC_ENTRY = 'sync_entry.sh'
SYNC_DATA  = 'gfid_file.txt'

SE_HEADER = "#!/bin/bash\n\n\
#Generated by parse-entry-failures.py\n\
#Usage: bash sync_entry.sh <master-aux-mnt> <slave-aux-mnt>\n\n"

SE_FUNC = "entry_sync() {\n\
    mast_mnt=$1\n\
    slv_mnt=$2\n\n\
    pgfid=$3\n\
    fname=$4\n\
    gfid=$5\n\
    ty=$6\n\
    uid=$7\n\
    gid=$8\n\
    mode=$9\n\n\
    if [ -e $mast_mnt/$entry ]\n\
    then\n\
        python gfid-access.py $slv_mnt $pgfid $fname $gfid $ty $uid $gid $mode\n\
    fi\n\
}\n\n\n"
                   
               
def parse_json (line):
    data = line.split(" FAILED: (")[-1]
    data = data.rsplit("},", 1)[0]
    data = data + '}'
    return data.replace("'", '"')

def print_usage ():
    print "Usage: python parse_entry_failures <georep_log_file>"

def args_check_0():
    if len(sys.argv) < 2:
        print "ERROR: Insufficient arguments."
        exit(1)

    if not os.path.exists(sys.argv[1]):
        print("ERROR: log file %s doesn't exist" % sys.argv[1])
        print_usage()
        exit(1)

def main():

    args_check_0()

    log_file = sys.argv[1]

    enot_sup = False
    if os.path.exists(SYNC_ENTRY):
        os.unlink(SYNC_ENTRY)
    if os.path.exists(SYNC_DATA):
        os.unlink(SYNC_DATA)

    entryRepeated = False
    metaRepeated = False
    prev_entry = ""
    prev_meta = ""
 
    entry_fp = open (SYNC_ENTRY, 'a')
    entry_fp.write(SE_HEADER)
    entry_fp.write(SE_FUNC)
    data_fp = open (SYNC_DATA, 'a')
    with open (log_file) as f:
        for line in f:
            if "ENTRY FAILED" in line:
                json_data = json.loads(parse_json(line))
                if prev_entry == json_data['entry']:
                    entryRepeated = True
                if not entryRepeated:
                    if json_data['op'] in ['MKNOD', 'CREATE']:
                        ty = "file"
                    elif json_data['op'] in ['MKDIR']:
                        ty = "dir"
                    elif json_data['op'] in ['SYMLINK']:
                        print "Ignoring SYMLINK"
                        enot_sup = True
                    elif json_data['op'] in ['LINK']:
                        print "Ignoring LINK"
                        enot_sup = True
                    else:
                        print "Ignoring unsupported op:%s" % json_data['op']
                        enot_sup = True
                    if not enot_sup:
                        entry_fp.write("entry_sync $1 $2 %s %s %s %s %s %s %s\n" % (json_data['entry'].split('/')[1], json_data['entry'].split('/')[2], json_data['gfid'], ty, str(json_data['uid']), str(json_data['gid']), str(json_data['mode'])))
                        data_fp.write(".gfid/%s\n" % json_data['gfid'])
                prev_entry = json_data['entry']
                entryRepeated = False
            elif "META FAILED" in line:
                json_data = json.loads(parse_json(line))
                if prev_meta == json_data['go']:
                    metaRepeated = True
                if not metaRepeated:
                    data_fp.write("%s\n" % json_data['go'])
                prev_meta = json_data['go']
                metaRepeated = False

    entry_fp.close()
    data_fp.close()

if __name__ == '__main__':
    main()
