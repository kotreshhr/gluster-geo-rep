import sys
import os
import json

GFID_ACCESS = 'python $1'
SYNC_ENTRY = 'sync_entry.py'
SYNC_DATA  = 'gfid_file.txt'

SE_HEADER = "import os\nfrom resource import *\n\n\
#Generated by parse-entry-failures.py\n\
#Usage: python sync_entry.py <master-aux-mnt> <slave-aux-mnt>\n\n"

SE_WRAP_FUNC = """
def entry_sync(mst_mnt, slv_mnt, entry):
    entry = eval(entry)
    if (os.path.lexists(mst_mnt + '/.gfid/' + entry['gfid'])):
        try:
            entry_ops(slv_mnt, entry)
        except (OSError, IOError):
            sys.stderr.write("ENTRY FAILED: %s\\n" % repr(entry))

def sync_all_entries(mst_mnt, slv_mnt):
"""

FOOTER = """
if __name__ == '__main__':
    if len(sys.argv) < 3:
        print('USAGE: %s <mst-aux-mnt> <slv-aux-mnt>' % (sys.argv[0]))
        sys.exit(-1)
    mst_mnt = sys.argv[1]
    slv_mnt = sys.argv[2]
    sync_all_entries(mst_mnt, slv_mnt)
"""

def parse_json (line):
    data = line.split(" FAILED: (")[-1]
    data = data.split("data=")[-1]
    return data.strip()

def print_usage ():
    print "Usage: python parse_entry_failures <georep_log_file> <any-master-brick_path>"

def args_check_0():
    if len(sys.argv) < 3:
        print "ERROR: Insufficient arguments."
        exit(1)

    if not os.path.exists(sys.argv[1]):
        print("ERROR: log file %s doesn't exist" % sys.argv[1])
        print_usage()
        exit(1)

    if not os.path.exists(sys.argv[2]):
        print("ERROR: brick path %s doesn't exist" % sys.argv[2])
        print_usage()

def main():

    args_check_0()

    log_file = sys.argv[1]
    brick_path = sys.argv[2]

    enot_sup = False
    if os.path.exists(SYNC_ENTRY):
        os.unlink(SYNC_ENTRY)
    if os.path.exists(SYNC_DATA):
        os.unlink(SYNC_DATA)

    entryRepeated = False
    metaRepeated = False
    prev_entry = ""
    prev_meta = ""

    entry_fp = open (SYNC_ENTRY, 'a')
    entry_fp.write(SE_HEADER)
    entry_fp.write(SE_WRAP_FUNC)
    data_fp = open (SYNC_DATA, 'a')
    with open (log_file) as f:
        for line in f:
            if "ENTRY FAILED" in line:
                json_data = eval(parse_json(line))
                if prev_entry == json_data[0]['entry']:
                    entryRepeated = True
                if not entryRepeated and json_data[0]['op'] == 'MKDIR' and len(json_data) == 3:
                    egfid = json_data[2]
                    try:
                        path = os.readlink(os.path.join(brick_path, ".glusterfs", egfid[0:2], egfid[2:4], egfid))
                        pgfid_bname=os.path.join(".gfid", os.path.dirname(path).split('/')[-1], os.path.basename(path))
                        json_data2 = {'op': 'RENAME', 'gfid': egfid, 'entry':json_data[0]['entry'], 'entry1':pgfid_bname, 'stat':{}}
                        entry_fp.write("    entry_sync(mst_mnt, slv_mnt, \"%s\")\n" % (json_data2))
                    except OSError:
                        pass
                if not entryRepeated:
                    entry_fp.write("    entry_sync(mst_mnt, slv_mnt, \"%s\")\n" % (json_data[0]))
                    data_fp.write(".gfid/%s\n" % json_data[0]['gfid'])
                prev_entry = json_data[0]['entry']
                entryRepeated = False
            elif "META FAILED" in line:
                json_data = eval(parse_json(line))
                if prev_meta == json_data[0]['go']:
                    metaRepeated = True
                if not metaRepeated:
                    data_fp.write("%s\n" % json_data[0]['go'])
                prev_meta = json_data[0]['go']
                metaRepeated = False

    entry_fp.write(FOOTER)
    entry_fp.close()
    data_fp.close()

if __name__ == '__main__':
    main()
